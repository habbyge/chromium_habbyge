// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package org.chromium.content.browser.accessibility;

import static org.chromium.content.browser.accessibility.AccessibilityContentShellActivityTestRule.EVENTS_ERROR;
import static org.chromium.content.browser.accessibility.AccessibilityContentShellActivityTestRule.RESULTS_NULL;
import static org.chromium.content.browser.accessibility.AccessibilityContentShellTestUtils.sClassNameMatcher;
import static org.chromium.content.browser.accessibility.WebContentsAccessibilityImpl.EXTRAS_KEY_SUPPORTED_ELEMENTS;
import static org.chromium.content.browser.accessibility.WebContentsAccessibilityImpl.EXTRAS_KEY_UNCLIPPED_BOTTOM;
import static org.chromium.content.browser.accessibility.WebContentsAccessibilityImpl.EXTRAS_KEY_UNCLIPPED_TOP;

import static java.lang.String.CASE_INSENSITIVE_ORDER;

import android.annotation.SuppressLint;
import android.annotation.TargetApi;
import android.os.Build;
import android.os.Bundle;
import android.text.InputType;
import android.text.TextUtils;
import android.view.accessibility.AccessibilityNodeInfo;

import androidx.test.filters.SmallTest;

import org.junit.Assert;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import org.chromium.base.test.util.MinAndroidSdkLevel;
import org.chromium.content_public.browser.test.ContentJUnit4ClassRunner;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Tests for WebContentsAccessibilityImpl integration with accessibility services.
 */
@RunWith(ContentJUnit4ClassRunner.class)
@MinAndroidSdkLevel(Build.VERSION_CODES.LOLLIPOP)
@TargetApi(Build.VERSION_CODES.LOLLIPOP)
@SuppressLint("VisibleForTests")
public class WebContentsAccessibilityTreeTest {
    // File path that holds all the relevant tests.
    private static final String BASE_ARIA_FILE_PATH = "content/test/data/accessibility/aria/";
    private static final String BASE_HTML_FILE_PATH = "content/test/data/accessibility/html/";

    // All HTML elements that can be traversed through, should be the same for all tests. Taken
    // from: content/browser/accessibility/web_contents_accessibility_android.cc
    private static final String ALL_HTML_ELEMENT_PREDICATES =
            "ARTICLE,BUTTON,CHECKBOX,COMBOBOX,CONTROL,FOCUSABLE,FRAME,GRAPHIC,H1,H2,H3,H4,H5,H6,"
            + "HEADING,LANDMARK,LINK,LIST,LIST_ITEM,MAIN,MEDIA,RADIO,SECTION,TABLE,TEXT_FIELD,"
            + "UNVISITED_LINK,VISITED_LINK";
    private static final String PREDICATES_ERROR =
            "HTML predicates did not match expectations, was a new predicate added to predicate "
            + "map of web_contents_accessibility_android.cc?";

    @Rule
    public AccessibilityContentShellActivityTestRule mActivityTestRule =
            new AccessibilityContentShellActivityTestRule();

    /**
     * Perform a single test which will:
     *      1. Open the given HTML file
     *      2. Generate the full AccessibilityNodeInfo tree
     *      3. Read expectations file and compare with results
     *
     * @param inputFile                     HTML test input file
     * @param inputFile                     HTML test input file
     * @param expectationFile               TXT expectations file
     * @param expectationFilePath           directory that holds the test files
     */
    private void performTest(String inputFile, String expectationFile, String expectationFilePath) {
        // Build page from given file and enable testing framework.
        mActivityTestRule.setupTestFromFile(expectationFilePath + inputFile);

        // Generate full AccessibilityNodeInfo tree and verify results.
        assertResults(expectationFilePath + expectationFile, generateAccessibilityNodeInfoTree());
    }

    // Helper methods to pass-through to the performTest method so each individual test does
    // not need to include its own filepath.
    private void performAriaTest(String inputFile, String expectationFile) {
        performTest(inputFile, expectationFile, BASE_ARIA_FILE_PATH);
    }

    private void performHtmlTest(String inputFile, String expectationFile) {
        performTest(inputFile, expectationFile, BASE_HTML_FILE_PATH);
    }

    /**
     * Helper method to compare test outputs with expected results. Reads content of expectations
     * file, asserts non-null, then compares with results.
     *
     * @param expectationFile           File of the expectations for the test (including path)
     * @param actualResults             Actual results generated by the accessibility code
     */
    private void assertResults(String expectationFile, String actualResults) {
        String expectedResults = mActivityTestRule.readExpectationFile(expectationFile);

        Assert.assertNotNull(RESULTS_NULL, actualResults);
        Assert.assertEquals(EVENTS_ERROR + "\n\nExpected:\n" + expectedResults + "\n\nActual:\n"
                        + actualResults + "\n\n",
                expectedResults, actualResults);
    }

    /**
     * Generate the full AccessibilityNodeInfo tree as a String of text.
     *
     * @return String                   The AccessibilityNodeInfo tree in text form
     */
    private String generateAccessibilityNodeInfoTree() {
        StringBuilder builder = new StringBuilder();

        // Find the root node and generate its string.
        int rootNodevvId =
                mActivityTestRule.waitForNodeMatching(sClassNameMatcher, "android.webkit.WebView");
        AccessibilityNodeInfo nodeInfo = createAccessibilityNodeInfo(rootNodevvId);
        builder.append(customToString(nodeInfo));

        // Recursively generate strings for all descendants.
        for (int i = 0; i < nodeInfo.getChildCount(); ++i) {
            int childId = mActivityTestRule.getChildId(nodeInfo, i);
            AccessibilityNodeInfo childNodeInfo = createAccessibilityNodeInfo(childId);
            recursivelyFormatTree(childNodeInfo, builder, "++");
        }

        return builder.toString();
    }

    /**
     * Recursively add AccessibilityNodeInfo descendants to the given builder.
     *
     * @param node                       Given object to print all descendants for
     * @param builder                    builder to add generated Strings to
     * @param indent                     prefix to indent each generation, e.g. "++"
     */
    private void recursivelyFormatTree(
            AccessibilityNodeInfo node, StringBuilder builder, String indent) {
        builder.append("\n").append(indent).append(customToString(node));
        for (int j = 0; j < node.getChildCount(); ++j) {
            int childId = mActivityTestRule.getChildId(node, j);
            AccessibilityNodeInfo childNodeInfo = createAccessibilityNodeInfo(childId);
            recursivelyFormatTree(childNodeInfo, builder, indent + "++");
        }
    }

    // Helper method to create an AccessibilityNodeInfo object.
    private AccessibilityNodeInfo createAccessibilityNodeInfo(int virtualViewId) {
        return mActivityTestRule.mNodeProvider.createAccessibilityNodeInfo(virtualViewId);
    }

    /**
     * Helper method to perform a custom toString on a given AccessibilityNodeInfo object.
     *
     * @param node                        Object to create a toString for
     * @return  String                    Custom toString result for the given object
     */
    private String customToString(AccessibilityNodeInfo node) {
        StringBuilder builder = new StringBuilder();

        // Print classname first, but only print content after the last period to remove redundancy.
        String[] classNameParts = node.getClassName().toString().split("\\.");
        builder.append(classNameParts[classNameParts.length - 1]);

        // Print text unless it is empty (null is allowed)
        if (node.getText() == null || !node.getText().toString().isEmpty()) {
            builder.append(" text:\"").append(node.getText()).append("\"");
        }

        // Text properties - Only print when non-null
        if (node.getContentDescription() != null) {
            builder.append(" contentDescription:\"")
                    .append(node.getContentDescription())
                    .append("\"");
        }
        if (node.getViewIdResourceName() != null) {
            builder.append(" viewIdResName:\"").append(node.getViewIdResourceName()).append("\"");
        }
        if (node.getError() != null) {
            builder.append(" error:\"").append(node.getError()).append("\"");
        }

        // Boolean properties - Only print when set to true except for enabled and visibleToUser,
        // which are both mostly true, so only print when they are false.
        if (node.canOpenPopup()) {
            builder.append(" canOpenPopUp");
        }
        if (node.isCheckable()) {
            builder.append(" checkable");
        }
        if (node.isChecked()) {
            builder.append(" checked");
        }
        if (node.isClickable()) {
            builder.append(" clickable");
        }
        if (node.isContentInvalid()) {
            builder.append(" contentInvalid:");
        }
        if (node.isDismissable()) {
            builder.append(" dismissable");
        }
        if (node.isEditable()) {
            builder.append(" editable");
        }
        if (!node.isEnabled()) {
            builder.append(" disabled");
        }
        if (node.isFocusable()) {
            builder.append(" focusable");
        }
        if (node.isFocused()) {
            builder.append(" focused");
        }
        if (node.isMultiLine()) {
            builder.append(" multiLine");
        }
        if (node.isPassword()) {
            builder.append(" password");
        }
        if (node.isScrollable()) {
            builder.append(" scrollable");
        }
        if (node.isSelected()) {
            builder.append(" selected");
        }
        if (!node.isVisibleToUser()) {
            builder.append(" notVisibleToUser");
        }

        // Integer properties - Only print when not default values.
        if (node.getInputType() != InputType.TYPE_NULL) {
            builder.append(" inputType:").append(node.getInputType());
        }
        if (node.getTextSelectionStart() != -1) {
            builder.append(" textSelectionStart:").append(node.getTextSelectionStart());
        }
        if (node.getTextSelectionEnd() != -1) {
            builder.append(" textSelectionEnd:").append(node.getTextSelectionEnd());
        }
        if (node.getMaxTextLength() != -1) {
            builder.append(" maxTextLength:").append(node.getMaxTextLength());
        }

        // Child objects - print for non-null cases.
        if (node.getCollectionInfo() != null) {
            builder.append(" CollectionInfo:")
                    .append(collectionInfoToString(node.getCollectionInfo()));
        }
        if (node.getCollectionItemInfo() != null) {
            builder.append(" CollectionItemInfo:")
                    .append(collectionItemInfoToString(node.getCollectionItemInfo()));
        }
        if (node.getRangeInfo() != null) {
            builder.append(" RangeInfo:").append(rangeInfoToString(node.getRangeInfo()));
        }

        // Actions and Bundle extras - Always print.
        builder.append(" actions:").append(actionsToString(node));
        builder.append(" bundle:").append(bundleToString(node.getExtras()));

        return builder.toString();
    }

    // Various helper methods to print custom toStrings for objects.
    private String collectionInfoToString(AccessibilityNodeInfo.CollectionInfo info) {
        // Only include the isHierarchical boolean if true, since it is more often false, and
        // ignore selection mode, which is not set by Chrome.
        String prefix = "[";
        if (info.isHierarchical()) {
            prefix += "hierarchical, ";
        }
        return prefix + "rows=" + info.getRowCount() + ", cols=" + info.getColumnCount() + "]";
    }

    private String collectionItemInfoToString(AccessibilityNodeInfo.CollectionItemInfo info) {
        // Only include isHeading and isSelected if true, since both are more often false.
        String prefix = "[";
        if (info.isHeading()) {
            prefix += "heading, ";
        }
        if (info.isSelected()) {
            prefix += "selected, ";
        }
        return prefix + "rowIndex=" + info.getRowIndex() + ", rowSpan=" + info.getRowSpan()
                + ", colIndex=" + info.getColumnIndex() + ", colSpan=" + info.getColumnSpan() + "]";
    }

    private String rangeInfoToString(AccessibilityNodeInfo.RangeInfo info) {
        // Chrome always uses the float range type, so only print values of RangeInfo.
        return "[current=" + info.getCurrent() + ", min=" + info.getMin() + ", max=" + info.getMax()
                + "]";
    }

    private String actionsToString(AccessibilityNodeInfo node) {
        // Sort actions list to ensure consistent output of tests.
        Collections.sort(node.getActionList(), (a1, b2) -> Integer.compare(a1.getId(), b2.getId()));

        List<String> actionStrings = new ArrayList<String>();
        StringBuilder builder = new StringBuilder();
        builder.append("[");
        for (AccessibilityNodeInfo.AccessibilityAction action : node.getActionList()) {
            // Four actions are set on all nodes, so ignore those when printing the tree.
            if (action.getId() == AccessibilityNodeInfo.ACTION_NEXT_HTML_ELEMENT
                    || action.getId() == AccessibilityNodeInfo.ACTION_PREVIOUS_HTML_ELEMENT
                    || action.getId() == WebContentsAccessibilityImpl.ACTION_SHOW_ON_SCREEN
                    || action.getId() == WebContentsAccessibilityImpl.ACTION_CONTEXT_CLICK) {
                continue;
            }

            actionStrings.add(actionToString(action.getId()));
        }
        builder.append(TextUtils.join(", ", actionStrings)).append("]");

        return builder.toString();
    }

    private String actionToString(int action) {
        switch (action) {
            // These could potentially be added to any given node.
            case AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY:
                return "NEXT";
            case AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY:
                return "PREVIOUS";
            case AccessibilityNodeInfo.ACTION_SET_TEXT:
                return "SET_TEXT";
            case AccessibilityNodeInfo.ACTION_PASTE:
                return "PASTE";
            case WebContentsAccessibilityImpl.ACTION_IME_ENTER:
                return "IME_ENTER";
            case AccessibilityNodeInfo.ACTION_SET_SELECTION:
                return "SET_SELECTION";
            case AccessibilityNodeInfo.ACTION_CUT:
                return "CUT";
            case AccessibilityNodeInfo.ACTION_COPY:
                return "COPY";
            case AccessibilityNodeInfo.ACTION_SCROLL_FORWARD:
                return "SCROLL_FORWARD";
            case AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD:
                return "SCROLL_BACK";
            case WebContentsAccessibilityImpl.ACTION_SCROLL_UP:
                return "SCROLL_UP";
            case WebContentsAccessibilityImpl.ACTION_PAGE_UP:
                return "PAGE_UP";
            case WebContentsAccessibilityImpl.ACTION_SCROLL_DOWN:
                return "SCROLL_DOWN";
            case WebContentsAccessibilityImpl.ACTION_PAGE_DOWN:
                return "PAGE_DOWN";
            case WebContentsAccessibilityImpl.ACTION_SCROLL_LEFT:
                return "SCROLL_LEFT";
            case WebContentsAccessibilityImpl.ACTION_PAGE_LEFT:
                return "PAGE_LEFT";
            case WebContentsAccessibilityImpl.ACTION_SCROLL_RIGHT:
                return "SCROLL_RIGHT";
            case WebContentsAccessibilityImpl.ACTION_PAGE_RIGHT:
                return "PAGE_RIGHT";
            case AccessibilityNodeInfo.ACTION_CLEAR_FOCUS:
                return "CLEAR_FOCUS";
            case AccessibilityNodeInfo.ACTION_FOCUS:
                return "FOCUS";
            case AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS:
                return "CLEAR_A11Y_FOCUS";
            case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS:
                return "A11Y_FOCUS";
            case AccessibilityNodeInfo.ACTION_CLICK:
                return "CLICK";
            case AccessibilityNodeInfo.ACTION_EXPAND:
                return "EXPAND";
            case AccessibilityNodeInfo.ACTION_COLLAPSE:
                return "COLLAPSE";
            case WebContentsAccessibilityImpl.ACTION_SET_PROGRESS:
                return "SET_PROGRESS";

            // The long click action is deliberately never be added to a node.
            case AccessibilityNodeInfo.ACTION_LONG_CLICK:
            // These are the remaining potential actions which Chrome does not implement.
            case AccessibilityNodeInfo.ACTION_DISMISS:
            case AccessibilityNodeInfo.ACTION_SELECT:
            case AccessibilityNodeInfo.ACTION_CLEAR_SELECTION:
            case WebContentsAccessibilityImpl.ACTION_SCROLL_TO_POSITION:
            case WebContentsAccessibilityImpl.ACTION_MOVE_WINDOW:
            case WebContentsAccessibilityImpl.ACTION_SHOW_TOOLTIP:
            case WebContentsAccessibilityImpl.ACTION_HIDE_TOOLTIP:
            case WebContentsAccessibilityImpl.ACTION_PRESS_AND_HOLD:
            default:
                return "NOT_IMPLEMENTED";
        }
    }

    private String bundleToString(Bundle extras) {
        // Sort keys to ensure consistent output of tests.
        List<String> sortedKeySet = new ArrayList<String>(extras.keySet());
        Collections.sort(sortedKeySet, CASE_INSENSITIVE_ORDER);

        List<String> bundleStrings = new ArrayList<>();
        StringBuilder builder = new StringBuilder();
        builder.append("[");
        for (String key : sortedKeySet) {
            // Two Bundle extras are related to bounding boxes, these should be ignored so the
            // tests can safely run on varying devices and not be screen-dependent.
            if (key.equals(EXTRAS_KEY_UNCLIPPED_TOP) || key.equals(EXTRAS_KEY_UNCLIPPED_BOTTOM)) {
                continue;
            }

            // Since every node has a few Bundle extras, and some are often empty, we will only
            // print non-null and not empty values.
            if (extras.get(key) == null || extras.get(key).toString().isEmpty()) {
                continue;
            }

            // For the special case of the supported HTML elements, which prints the same for the
            // rootWebArea on each test, assert consistency and suppress from results.
            if (key.equals(EXTRAS_KEY_SUPPORTED_ELEMENTS)) {
                Assert.assertEquals(
                        PREDICATES_ERROR, ALL_HTML_ELEMENT_PREDICATES, extras.get(key).toString());
                continue;
            }

            // Simplify the key String before printing to make test outputs easier to read.
            bundleStrings.add(key.replace("AccessibilityNodeInfo.", "") + "=\""
                    + extras.get(key).toString() + "\"");
        }
        builder.append(TextUtils.join(", ", bundleStrings)).append("]");

        return builder.toString();
    }

    @Test
    @SmallTest
    public void test_annotationRoles() {
        performAriaTest("annotation-roles.html", "annotation-roles-expected-android-external.txt");
    }

    @Test
    @SmallTest
    public void test_tableSimple() {
        performHtmlTest("table-simple.html", "table-simple-expected-android-external.txt");
    }

    @Test
    @SmallTest
    public void test_clickableScore() {
        performHtmlTest("clickable-score.html", "clickable-score-expected-android-external.txt");
    }
}