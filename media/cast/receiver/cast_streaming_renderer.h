// Copyright 2021 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MEDIA_CAST_RECEIVER_CAST_STREAMING_RENDERER_H_
#define MEDIA_CAST_RECEIVER_CAST_STREAMING_RENDERER_H_

#include <memory>

#include "base/memory/weak_ptr.h"
#include "media/base/renderer.h"
#include "media/mojo/mojom/renderer.mojom.h"
#include "mojo/public/cpp/bindings/pending_receiver.h"
#include "mojo/public/cpp/bindings/receiver.h"

namespace media {
namespace cast {

// This class defines a Renderer to be used with Cast Streaming. It is intended
// to be used for both the Cast Mirroring and Cast Remoting scenarios,
// specifically to streams generated by desktop or tab mirroring / remoting. The
// Initialize call is delegated to the |real_renderer_| while all other calls
// are no-ops. Instead, only in the case of remoting, these commands are sent
// from the user device and communicated here over the ctor-provided
// |pending_rederer_controls|.
//
// The mirroring can be summarized as being that of a user is trying to take
// what's currently displayed on their device, and send those bits to a larger
// screen. So it should be an exact duplicate of what they see locally - a
// faithful copy. Streams generated by mirroring screen contents from the sender
// device consist of demuxed media frames, and are simply played out in real
// time on the delegated Renderer. Remoting, by comparison, is simply an
// optimization on top of mirroring - in practice, the receiver here cannot
// (and does not need to) distinguish between the two. Mirroring does not accept
// media commands because, by definition, it is mirroring some content, so there
// is no notion of starting playback, seeking around, et cetera. For remoting,
// commands sent by the user over mojo are used to control playback. That being
// said, as this Renderer does not differentiate between its use for Mirroring
// and Remoting (and that a streaming session may change between the two without
// re-creating the Renderer), playback commands sent over Mojo will be respected
// regardless of which Cast Streaming type is being used.
//
// Therefore, the |pending_rederer_controls| serves two purposes:
// - Playback control during a Remoting session.
// - Starting playback of any Cast Streaming session once the browser process
//   has begun streaming end-user provided data.
//
// Currently, this renderer is only used on Chromecast receivers.
class CastStreamingRenderer : public Renderer {
 public:
  // |renderer| is the Renderer to which the Initialize() call should be
  // delegated.
  // |task_runner| is the task runner on which mojo calls should be run.
  // |pending_receiver_controls| is the remote Receiver which will be providing
  // playback commands to this instance.
  CastStreamingRenderer(
      std::unique_ptr<Renderer> renderer,
      scoped_refptr<base::SingleThreadTaskRunner> task_runner,
      mojo::PendingReceiver<media::mojom::Renderer> pending_rederer_controls);
  CastStreamingRenderer(const CastStreamingRenderer&) = delete;
  CastStreamingRenderer(CastStreamingRenderer&&) = delete;

  ~CastStreamingRenderer() override;

  CastStreamingRenderer& operator=(const CastStreamingRenderer&) = delete;
  CastStreamingRenderer& operator=(CastStreamingRenderer&&) = delete;

  // Renderer overrides.
  //
  // Calls into |real_renderer_|'s method of the same name.
  void Initialize(MediaResource* media_resource,
                  RendererClient* client,
                  PipelineStatusCallback init_cb) override;

  // Further Renderer overrides as no-ops. In the remoting scenario, these
  // commands will be received from the end-user's device over mojo.
  void SetCdm(CdmContext* cdm_context, CdmAttachedCB cdm_attached_cb) override;
  void SetLatencyHint(absl::optional<base::TimeDelta> latency_hint) override;
  void Flush(base::OnceClosure flush_cb) override;
  void StartPlayingFrom(base::TimeDelta time) override;
  void SetPlaybackRate(double playback_rate) override;
  void SetVolume(float volume) override;
  base::TimeDelta GetMediaTime() override;

 private:
  // Class responsible for receiving Renderer commands from a remote source and
  // acting on |real_renderer_| appropriately. This logic has been separated
  // from the parent class to avoid the complexity associated with having
  // both media::Renderer and media::mojo::Renderer implemented side-by-side.
  class PlaybackController : public media::mojom::Renderer {
   public:
    PlaybackController(
        mojo::PendingReceiver<media::mojom::Renderer> pending_rederer_controls,
        scoped_refptr<base::SingleThreadTaskRunner> task_runner,
        media::Renderer* real_renderer);
    ~PlaybackController() override;

    // media::mojom::Renderer overrides.
    void StartPlayingFrom(::base::TimeDelta time) override;
    void SetPlaybackRate(double playback_rate) override;

    // The following overrides are not currently implemented.
    //
    // TODO(b/182429524): Implement these methods.
    void Initialize(
        ::mojo::PendingAssociatedRemote<media::mojom::RendererClient> client,
        absl::optional<
            std::vector<::mojo::PendingRemote<::media::mojom::DemuxerStream>>>
            streams,
        mojom::MediaUrlParamsPtr media_url_params,
        InitializeCallback callback) override;
    void Flush(FlushCallback callback) override;
    void SetVolume(float volume) override;
    void SetCdm(const absl::optional<::base::UnguessableToken>& cdm_id,
                SetCdmCallback callback) override;

   private:
    media::Renderer* const real_renderer_;
    scoped_refptr<base::SingleThreadTaskRunner> task_runner_;
    mojo::Receiver<media::mojom::Renderer> playback_controller_;
    base::WeakPtrFactory<PlaybackController> weak_factory_;
  };

  void OnRealRendererInitializationComplete(PipelineStatus status);

  // Renderer to which playback calls should be forwarded.
  std::unique_ptr<Renderer> real_renderer_;

  // Callback provided to this class as part of the Initialize() call. Called in
  // OnRealRendererInitializationComplete().
  PipelineStatusCallback init_cb_;

  // Provided in the ctor and passed to |playback_controller_| upon its creation
  // in OnRealRendererInitializationComplete().
  mojo::PendingReceiver<media::mojom::Renderer> pending_renderer_controls_;

  // Task runner on which all mojo callbacks will be run.
  scoped_refptr<base::SingleThreadTaskRunner> task_runner_;

  // Created as part of OnRealRendererInitializationComplete().
  std::unique_ptr<PlaybackController> playback_controller_;

  base::WeakPtrFactory<CastStreamingRenderer> weak_factory_;
};

}  // namespace cast
}  // namespace media

#endif  // MEDIA_CAST_RECEIVER_CAST_STREAMING_RENDERER_H_
